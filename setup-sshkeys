#!/bin/bash
## Generate Public/Private Key Pairs for Keyless Login to Remote Host

lochost=$(hostname)
locuname=$(whoami)

remhost=$(hostname)
remuname=$(whoami)

ssh_home="/Users/$(whoami)/.ssh"
sshagentfile="/Users/$(whoami)/.ssh_agent"

keytype='rsa'
privkey='id_'${keytype}
pubkey='/id_'${keytype}'.pub'
x11=''

proceed=''
quiet=''
resetkeys=''
handshake=''

rseed=0 # used for creating random key name for remote (security measure)
# Define Function
## Print Usage Information
function show_help(){
cat <<EOF

Usage ${0##*/} [-h|--help] [-host ADDRESS] [-uname USERNAME] [-sshagent FILE][-sshdir PATH] [-prvkey FILE]
                    [--x11] [--reset] [--2waytunnel]

This program checks for existence of private/public keypairs for passwordless ssh logins between remote and local host.

    REQUIRED ARGUMENTS  
    
        -host       address of remote server to set up logins keys
        -uname      username credential for remote server

    SSH OPTIONS

        -sshagent   file for ssh-agent 
        -keytype    rsa | dsa
        -sshdir     path to .ssh directory (keys stored here)
        -prvkey     path to private key
        -pubkey     path to public key
        --x11        permit X11 forwarding 

    OTHER FLAGS

        --reset         delete sshdir and associated keys (CAUTION :: all host keys are deleted)
        --2waytunnel    create public/private keys on both hosts (bilateral keyless login)  
        --quiet         run with minimal user input
        --status        print parameters for ssh setup and exit


EOF
}


# Parse Options 
## Shift through standard input and assign to variables using option flags
while :; do
    case ${1} in
        -h|--help)
        show_help
        exit
        ;;
        -rsa)
            keytype='rsa'
        ;;
        -dsa)
            keytype='dsa'
        ;;        
        --x11)
            x11='-O permit-x11-forwarding'
        ;;
        --quiet)
            quiet='quiet'
        ;;
        --status)
            proceed='N'
        ;;
        --2waytunnel)
            handshake='2-way'        
        ;;
        --reset)
            resetkeys='true'
        ;;
        -host)
            if [ -n "${2}" ]; then
                remhost=${2}
                shift
            else                                                                                                                                                                                                                 
                echo "ERROR: -host requires a non-empty option argument.\n" >&2
                exit
            fi
            ;;
        -uname)
            if [ -n "${2}" ]; then
                remuname=${2}
                shift
            else
                echo "ERROR: -uname requires a non-empty option argument.\n" >&2
                exit
            fi
            ;;
        -sshagent)
            if [ -n "${2}" ]; then
                sshagentfile=$2
                shift
            else
                echo "ERROR: -sshagent requires a non-empty option argument.\n" >&2
                exit
            fi
            ;;
        -sshdir)
            if [ -n "${2}" ]; then
                ssh_home=$2
                shift
            else
                echo "ERROR: -sshdir requires a non-empty option argument.\n" >&2
                exit
            fi
            ;;
        -keytype)
            if [ -n "${2}" ]; then
                keytype=$2
                shift
            else
                echo "ERROR -keytype requires a non-empty option argument" >&2
                exit
            fi
            ;;                       
        -prvkey)
            if [ -n "${2}" ]; then
                privkey=$2
                shift
            else
                echo "ERROR: -prvkey requires a non-empty option argument.\n" >&2
                exit
            fi
            ;;
        -pubkey)
            if [ -n "${2}" ]; then
                pubkey=$2
                shift
            else
                echo "ERROR -pubkey requires a non-empty option argument" >&2
                exit
            fi
            ;;
        -?*)
            printf 'Warn: Unknown option (ignored): %s\n' "%1" >&2
            ;;
        *)
            break
    esac
    shift
done
## Assign Option String for SSH-KEYGEN
opts="-t ${keytype} ${x11}"
# Define Function
## This function displays options to user and asks for verification
function confirm_input(){
local confirm_user_input=$(cat <<-EOF
    \n
    Setting up Keyless SSH Tunnel :: ${locuname}@${lochost} üì°  ‚á¢  üîë  ‚á¢ ${remuname}@${remhost}
    \n
    \n
    \t    üñ•  HOST            ::      ${remhost}\n
    \t    üë§  USERNAME        ::      ${remuname}\n\n
    \t    üìÅ  SSHDIR          ::      ${ssh_home}\n
    \t    üìù  SSHAGENTFILE    ::      ${sshagentfile}\n
    \t    üîê  KEYTYPE         ::      ${keytype}\n\n
    \t    üîë  PRIVATEKEY      ::      ${privkey}\n
    \t    üóù  PUBLICKEY       ::      ${pubkey}\n\n    
    \t    ‚öô   KEYGEN OPTIONS  ::      ${opts}
EOF
    )   
# Check if user just wants to see status
[ ! ${proceed} ] || [ ! ${quiet} ] && echo -e ${confirm_user_input}
[ ! ${quiet} ] && [ -z ${proceed} ] && read -p "Setup New Handshake? [Y/N]  :: " proceed
[ ! ${quiet} ] && echo -e "\n"
}
# Define Function
## This function checks for existence of hidden ssh directory in user home and generates a
## public/private key pair and adds the public key to the authorized keys file.
function stdssh_genaddkeys(){
    # Check if ssh home dir exists and generate keys
	[ ! -d ${ssh_home} ] && mkdir -p ${ssh_home} && 'ssh-keygen' ${opts}
    echo -e "\n ** Adding public key to authorized keys and setting permissions\n"
	cat ${ssh_home}/${pubkey} >> ${ssh_home}/authorized_keys
	chmod 600 ${ssh_home}/authorized_keys
}
# Define Function
## This function takes a remote host, username, and path to a private key and copies it
## to the home directory on the remote host. 
function stdssh_cpkey(){
	local host=${1}
	local username=${2}
	local privkey=${3}
	local rseed=${RANDOM}
    echo -e "\n  üñ•   üì°  ü§ô  üéõ  üëç  Securely Transmitting Secret Handshake \n"
	scp ${ssh_home}/${privkey} ${username}@${host}:/tmp/${privkey}.transfer${rseed}
	ssh ${username}@${host} "mkdir ~/.keys; mv /tmp/${privkey}.transfer.${rseed} ~/.keys/; chmod 400 ~/.keys/${privkey}.transfer.${rseed}"
}
# Define Function
## Setup and add private key to agent
function stdssh_addagent(){
	local privkey=${1}
	ssh-agent > ${sshagentfile}
	source ${sshagentfile}
	ssh-add ${ssh_home}/${privkey}
    [ ! -e "~/.bash_logout" ] && echo -e "\n## quit ssh-agent at logout\n kill ${SSH_AGENT_PID}\n\n" > ~/.bash_logout 
    [ -e "~/.bash_logout" ] && echo -e "\n## quit ssh-agent at logout\n kill ${SSH_AGENT_PID}\n\n" >> ~/.bash_logout     
}
# Define Function
## Reset
function stdssh_reset(){
    ## Reset?
    if [ ${resetkeys} ]; then
        echo -e '\n'
        read -p "Are you sure you want to delete all ssh-agent files, .bash_logout and .ssh directory?  [Y/N]  :: " doublecheck
        if [ "${doublecheck}" = 'Y' ] || [ "${doublecheck}" = 'y' ]; then
            echo -e "\n\n üî•üóë  Removing All Local Keys, Authorized Hosts & ssh-agent Settings"
            rm -vr ${ssh_home}
            rm -v ${sshagentfile}
            rm -v /Users/$locuname/.bash_logout
            #echo -e "\n\n üì° ‚ö°Ô∏è ‚ö°Ô∏è  Removing All Remote Keys, Authorized Hosts & ssh-agent Settings"
            #ssh ${remuname}@${remhost} "rm -rv ~/.keys;"
        fi
    fi
}
# Define Function
## Run STDSSH for a 1-way handshake
function stdssh_run(){
    local host=${1}
    local username=${2}
    local privkey=${3}
    # Check for Reset
    stdssh_reset
    ## Confirm input arguments
    confirm_input
    ## Run Only if User Says Yes 
    [ "$proceed" = 'Y' ] || [ "proceed" = 'y' ] && stdssh_genaddkeys && stdssh_cpkey $host $username $privkey && stdssh_addagent $privkey
    ## Run Without User Check if Quiet Option is Presented
    #[ $quiet ] && stdssh_genaddkeys && stdssh_cpkey $host $username $privkey && stdssh_addagent $privkey && stdssh_cleanup
}

function stdssh(){
    stdssh_run $remhost $remuname $privkey
}

# Run STDSSH
'stdssh'

#####################################
### Shady El Damaty ; 24 April 2017
###
### stdssh
#####################################